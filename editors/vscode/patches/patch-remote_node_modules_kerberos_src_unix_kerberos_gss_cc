Index: remote/node_modules/kerberos/src/unix/kerberos_gss.cc
--- remote/node_modules/kerberos/src/unix/kerberos_gss.cc.orig
+++ remote/node_modules/kerberos/src/unix/kerberos_gss.cc
@@ -120,9 +120,9 @@ bool kerberos_libraries_available(std::string* error) 
 
 namespace node_kerberos {
 
-const char* krb5_get_err_text(const krb5_context&, krb5_error_code code) {
-    return COMERR_CALL(error_message)(code);
-}
+//const char* krb5_get_err_text(const krb5_context&, krb5_error_code code) {
+//    return COMERR_CALL(error_message)(code);
+//}
 
 static gss_result gss_success_result(int ret);
 static gss_result gss_error_result(OM_uint32 err_maj, OM_uint32 err_min);
@@ -138,7 +138,7 @@ gss_result server_principal_details(const char* servic
     int code;
     krb5_context kcontext;
     krb5_keytab kt = NULL;
-    krb5_kt_cursor cursor = NULL;
+    krb5_kt_cursor cursor;
     krb5_keytab_entry entry;
     char* pname = NULL;
 
@@ -174,12 +174,12 @@ gss_result server_principal_details(const char* servic
         if (strncmp(pname, match, match_len) == 0) {
             details = pname;
             KRB5_CALL(krb5_free_unparsed_name)(kcontext, pname);
-            KRB5_CALL(krb5_free_keytab_entry_contents)(kcontext, &entry);
+            //KRB5_CALL(krb5_free_keytab_entry_contents)(kcontext, &entry);
             break;
         }
 
         KRB5_CALL(krb5_free_unparsed_name)(kcontext, pname);
-        KRB5_CALL(krb5_free_keytab_entry_contents)(kcontext, &entry);
+        //KRB5_CALL(krb5_free_keytab_entry_contents)(kcontext, &entry);
     }
 
     if (details.empty()) {
@@ -189,8 +189,8 @@ gss_result server_principal_details(const char* servic
         result.data = std::move(details);
     }
 end:
-    if (cursor)
-        KRB5_CALL(krb5_kt_end_seq_get)(kcontext, kt, &cursor);
+    //if (cursor)
+    //    KRB5_CALL(krb5_kt_end_seq_get)(kcontext, kt, &cursor);
     if (kt)
         KRB5_CALL(krb5_kt_close)(kcontext, kt);
     KRB5_CALL(krb5_free_context)(kcontext);
@@ -223,7 +223,7 @@ gss_result authenticate_gss_client_init(const char* se
     name_token.value = (char*)service;
 
     maj_stat =
-        GSS_CALL(gss_import_name)(&min_stat, &name_token, GSS_VALUE(gss_nt_service_name), &state->server_name);
+        GSS_CALL(gss_import_name)(&min_stat, &name_token, GSS_VALUE(GSS_C_NT_HOSTBASED_SERVICE), &state->server_name);
 
     if (GSS_ERROR(maj_stat)) {
         ret = gss_error_result(maj_stat, min_stat);
